# Day 1: 시작이 반입니다

<img src="../../assets/kong-1.png" width="256">

React가 사라진 세상에서 살아남기 1일차입니다.

```sh
npm init
```

마음같아서는 당장 코드부터 작성해보고 싶습니다.  
당연해보이는 것들은 건너뛰고 상태를 정의하고, 이벤트, 렌더링이나 업데이트 전략을 세워야할 것만 같습니다.

하지만 빠르게 실행해보는 것만큼이나 중요한 것은,  
**나아가야 할 방향이 올바른지 충분히 고민**하는 것입니다.

또한 라이브러리나 프레임워크를 만든다면  
빠른 실행보다는 **설계의 방향성을 정하고 의사결정 기준을 마련하는 것**에 더 노력을 기울여야 합니다.  
익숙함에 지나쳤던 개념들이나 사소해보이는 요소들도 놓치지 않고 검토해야 합니다.

가벼운 질문으로 환기해보며 시작해보겠습니다.

> UI 라이브러리와 프레임워크는 어쩌다가 세상에 등장했을까요?

---

### [1] 왜 필요했을까요

웹은 본래 문서(Document)를 전달하기 위한 플랫폼이었습니다.  
웹 문서는 익히 알려진 세 개의 구성요소로 이루어져 있습니다.

- `HTML`은 Markup Language로 구조를 정의하고,
- `CSS`는 모양/표현을 담당하고,
- `JavaScript`는 기능/동작을 설명합니다.

이 구조는 **정적인 문서**를 표현하는 데는 충분했습니다.

하지만 웹의 역할이 점차 정적 문서를 넘어  
복잡한 상호작용과 비즈니스 서비스를 제공하는 **어플리케이션**(Application)으로 역할이 넓어지면서 문제가 생겼습니다.

우리가 익숙한 웹 어플리케이션에서는  
유저의 입력 동작과 서버와의 비동기 통신으로 내부 상태가 끊임없이 변화합니다.  
그리고 이 상태의 변화는 매번 화면의 변화로 이어져야 합니다.

UI의 개념 역시 '**한번 만들어지고 끝나는 시각적인 결과물**'를 넘어,  
문서의 '**내부 상태에 따라 끊임없이 갱신되어야 하는 대상**'으로 확장된 것입니다.  

여기서 '내부 상태'라는 표현은 문서가 가지고 있는 거의 모든 정보를 의미합니다.  
URL의 파라미터, API의 응답, Form의 정보, 단순한 객체까지 어플리케이션 안의 모든 '**stateful**'한 정보들을 상태라 칭합니다.  

이처럼 UI의 역할이 커지면서 자연스럽게 새로운 문제가 발생했습니다.

웹 서버에서 HTML을 생성해서 내려주거나,  
DOM을 명령형으로 직접 조작하는 방식에서는 개발자는 다음과 같은 질문을 계속해서 던져야 했던 것입니다.

> 지금 이 상태라면 화면은 어떤 모습이어야 하는가

내부 상태와 UI의 관계는 코드 곳곳에 흩어져있고,  
UI의 규모가 커질수록 이 **관계를 일관되게 유지하는 일**은 점차 어려워졌습니다.  
비즈니스 로직이 복잡해질수록,  
어떤 변경이 어떤 화면에 영향을 미치는지 예측하는 일도 함께 어려워질테구요.

React가 사라진 세상에 놓인 우리도 동일한 선상에서 출발합니다.  
우리가 만들어가는 `kongnamul`이 세상에 필요한 이유는 다음과 같이 표현할 수 있습니다.

```
웹 어플리케이션에서 상태와 UI 사이의 관계를 일관되게 유지하기 위해 존재합니다.
```

---

### [2] 무엇을 만들까요

우리는 무엇을 만들어야 할까요?

왜 만들어야하는지는 정했으니,  
이제는 `kongnamul`이라는 소프트웨어가 '**무엇**'이라는 명확한 정체성을 부여해야 할 시점입니다.

크게 두 가지 선택지가 있습니다.

> '프레임워크(Framework)를 만들까요, 라이브러리(Library)를 만들까요?'

(우리의 세상에서) 갑작스럽게 사라진 [React](https://react.dev/)는 스스로를 '라이브러리'라 표현하고 있습니다. [[1]](#appendix)  
직관적으로 수긍이 되시나요?

혹시 명확하게 그려지지 않는다면,  
그것은 라이브러리와 프레임워크를 나누는 기준이 **기능과 복잡도**가 아니기 때문일 겁니다.

'라이브러리와 프레임워크를 나누는 기준은 무엇인가요?'

무려 17년 전에도 StackOverflow에는 동일한 질문이 올라와 있습니다.

본 글 작성 시점 기준으로 624개의 upvote를 받은 답변이 있어 가져와 보았습니다.  
(출처: [StackOverflow](https://stackoverflow.com/questions/148747/what-is-the-difference-between-a-framework-and-a-library))

```
A library performs specific, well-defined operations.

A framework is a skeleton where the application defines the "meat" of the operation by filling out the skeleton. The skeleton still has code to link up the parts but the most important work is done by the application.

...(중략)
```

해석해보면 다음과 같습니다.

- 라이브러리는 특정 작업들을 수행하는 도구이며 **사용자가 필요할 때 호출**해서 사용합니다
- 프레임워크는 어플리케이션의 뼈대 역할을 제공하고, **그 안을 사용자의 코드로 채워넣어 실제 기능을 수행**합니다

둘을 구분하는 기준은 '**누가 누구를 호출하는지**'입니다.

라이브러리는 작성자가 라이브러리 코드를 호출하는 반면,  
프레임워크는 프레임워크가 작성자의 코드를 호출하는 구조입니다.  
이 차이를 소프트웨어 설계 관점에서 **IoC(Inversion of Control)**, 제어권의 역전이라는 용어로 표현합니다.

<img src="../assets/day-1_1.png" width="600">

`kongnamul`의 첫 번째 방향성을 정할 시간입니다.

프레임워크는 강력합니다.  
웹 어플리케이션의 구조를 정의하고 규칙을 강제하며  
작성자가 올바른 방향으로 코드를 작성하도록 유도할 수 있습니다.

결국 핵심은 **강제력**입니다.  
하지만 강제력은 **설계가 충분히 성숙했을 때만 안전**합니다.

우리는 풀어야 할 질문이 너무도 많은 상태입니다.  
이를테면 생명주기든, UI의 모델링이든, 상태 관리든 확정되지 않은 것들 투성이입니다.  
규칙을 발견해보고 개념의 타당성을 검증해보아야 합니다.

한 번 정해진 프레임워크의 규칙은 그 위에서 만들어지는 모든 코드에 영향을 줍니다.  
규칙이 틀렸거나 수정을 해야하면 교체 비용도 엄청납니다.

반면 라이브러리는 다릅니다.

라이브러리는 구조를 강제하지 않습니다.  
내부 구조를 비교적 투명하게 드러낼 수 있고, 설계 결정을 되돌리기 비교적 쉬운 편입니다.

지금은 완성된 정답을 제시하는 것이 아니라,  
UI를 만드는 도구로서의 설계를 하나씩 검증해보는 단계입니다.  
따라서 규칙은 자연스럽게 발견될 수는 있지만 처음부터 강제하는 선택은 좋지 않습니다.

따라서 `kongnamul`은 **라이브러리**라는 결정이 현재로서는 합리적입니다.

앞서 작성한 `kongnamul`의 존재 의의와 합쳐보면 다음과 같은 문장이 됩니다.

```
웹 어플리케이션에서 상태와 UI 사이의 관계를 일관되게 유지하기 위한 라이브러리입니다.
```

---

### [3] 안녕하세요 돔을 아시나요

지금까지 DOM이라는 표현이 여러 차례 등장했습니다.

제가 이해하고 있는 DOM은 이렇게 표현해볼 수 있을 것 같습니다.

> DOM(Document Object Model)은 웹 브라우저의 렌더링 과정에서 HTML 문서를 파싱하여 생성되는 **트리 구조의 객체**이며,  
> JavaScript와 같은 스크립트가 문서에 접근하고 조작할 수 있도록 **프로그래밍 인터페이스**를 제공합니다.

다들 알다시피 HTML 문서에는 `<div>`, `<p>` 와 같은 HTML 요소가 복잡한 계층 구조를 이루면서 작성되어 있습니다.  
웹 브라우저가 화면을 렌더링하는 과정(Critical Rendering Path)에서 HTML 문서를 파싱하면 다음과 같은 DOM Tree [[2]](#appendix)가 만들어집니다.

<img src="../assets/day-1_2.png" width="400">

또한 DOM은 트리 객체를 조작하기 위한 메소드를 제공하여 JavaScript나 스크립트가 접근하여 DOM 조작을 가능하게 해줍니다.  
`createElement`, `appendChild`와 같은 DOM API는 강력합니다.

앞선 [챕터](#1-왜-필요했을까요)에서도 가볍게 이야기했듯,  
문제는 결코 **DOM 조작 그 자체**가 아닙니다.

아주 간단한 숫자 카운터 UI를 만든다고 생각해봅시다.

```js
let count = 0;
const button = document.createElement("button");
const display = document.createElement("span");

display.textContent = count;
button.textContent = "+1";
button.addEventListener("click", () => {
  count += 1;
  display.textContent = count;
});
```

충분히 간단하게 느껴지시나요?

이 코드를 자세히 들여다보면, 개발자는 두 가지 일을 동시에 수행하고 있습니다.

1. **UI 구조 정의**: button과 span 요소를 만들고 텍스트를 설정
2. **상태와 UI 동기화**: count가 바뀔 때 display.textContent를 직접 갱신

후자의 경우, 개발자가 'count가 바뀌면 display를 업데이트해야 한다'는 관계를 명시적으로 코드로 작성하고 있습니다.  
문제는 **상태와 UI 사이의 관계를 개발자가 일일이 코드로 기술**한다는 것입니다.

`display.textContent = count`를 실행하면 화면은 즉시 업데이트됩니다.  
DOM은 '**실시간(Real-time)으로 반영되는 가변 객체**'라는 특징을 가지고 있습니다.

이 **실시간성과 가변성** 덕분에 DOM API는 강력하지만,  
동시에 개발자에게 **동기화의 책임**을 전가합니다.

> "상태 A가 바뀌면 UI의 B, C, D를 갱신해야 한다"  
> "상태 X와 Y가 동시에 바뀌면 어떤 순서로 렌더링해야 하는가"  
> "이전에 등록한 이벤트 리스너는 언제 제거해야 하는가"

이 모든 질문에 개발자가 답해야 합니다.

상태가 1개일 때는 괜찮습니다.  
하지만 5개, 10개로 늘어나고, 상태 간의 의존성이 생기고,  
API 비동기 호출이나 조건부 렌더링도 추가된다면 **복잡도는 폭발적으로 증가**합니다.

우리에게 필요한 것은 이 복잡도를 의도적으로 숨기는 **추상화**(Abstraction)입니다.   

`kongnamul` 역시 동기화의 책임을 라이브러리 내부에서 관리하기 위한 추상화를 도입해야 합니다.

하지만 '동기화의 책임을 라이브러리 내부에서 관리'한다는 말은 다소 모호하지 않나요?  
여기서 명령형 프로그래밍과 선언형 프로그래밍이라는 두 개의 패러다임이 자연스럽게 등장할 차례입니다.

---

### [4] 명령보다는 선언을 해봅시다

**명령형**(imperative) 프로그래밍과 **선언형**(declarative) 프로그래밍의 차이를 알고 계신가요?

우리가 오늘 점심으로 햄버거를 먹는다고 생각해봅시다.

명령형 프로그래밍은 햄버거를 먹기 위해 빵, 패티, 양상추, 토마토, 치즈와 같은 재료를 선택하고, 조리 방법을 전달하고, 어떤 순서로 쌓을지까지 그 모든 과정을 요리사에게 요청하는 것입니다.  
반면 선언형 프로그래밍은 햄버거 가게에 들어가서 메뉴판을 보고 치즈버거를 주문하면 치즈버거가 나오는 것이구요.

둘 다 점심으로 햄버거를 먹었다는 결과는 동일하지만, 굉장히 큰 차이가 있습니다.

즉, 프로그래밍 패러다임에서 명령형과 선언형의 핵심 차이는  
**어떻게(How)를 기술하느냐, 무엇(What)을 기술하느냐**입니다.

햄버거에서 UI 라이브러리 이야기로 돌아오자면,  
선언형 코드에서 개발자는 **이 상태일 때 UI는 이런 모습이어야 한다**만 기술합니다.  
상태가 바뀌면 어떤 DOM 노드를 찾아서 어떻게 갱신해야 하는지는 **기술하지 않습니다**.

'How'에 해당하는 과정은 누가 처리하는 걸까요?  
여기서 자연스럽게 **추상화**가 다시 등장합니다.

추상화란 **복잡한 내부 구현을 숨기고, 단순한 인터페이스만 노출하는 것**입니다.

우리가 치즈버거를 먹을 때 몇 분씩 어떻게 재료를 조리하고 어떤 순서로 쌓는지를 알 필요가 없이, 그저 햄버거 메뉴라는 **인터페이스**를 이용할 뿐입니다.  
그리고 메뉴라는 인터페이스를 제공하는 햄버거 가게가 바로 선언형 UI 라이브러리입니다.

개발자는 **무엇만 선언**하고, 라이브러리는 내부적으로 **어떻게를 처리**합니다.

물론 선언형 프로그래밍과 명령형 프로그래밍은 대척점에 있는 개념이지만,  
선언형 프로그래밍은 명령형 프로그래밍을 **대체**하는 것이 아닙니다. **감싸는(wrapping)** 것입니다.

햄버거를 단순히 주문할 뿐이지만, 햄버거를 만드는 과정이 없어진 것은 아닙니다.  
매장 주방 뒤에서 우리 눈에 보이지 않을 뿐입니다.

마찬가지로 선언형 UI 라이브러리 내부에서는  
여전히 `createElement`, `appendChild`, `removeChild` 같은 명령형 DOM API가 실행됩니다.

개발자는 더 이상 'A가 바뀌면 B를 업데이트하고, C가 바뀌면 D를 업데이트해야지'라고 생각할 필요가 없습니다.  
그저 **현재 상태에서 UI는 어떤 모습이어야 하는가**만 선언하면 됩니다.

이것이 바로 `kongnamul`이 제공하려는 추상화입니다.

선언형 프로그래밍의 개념을 한 스푼 담아 기존 `kongnamul`의 정의를 조금 더 다듬어보겠습니다.

```
웹 어플리케이션의 UI를 선언적으로 관리하는 라이브러리입니다.
```

---

### [5] 마치며

오늘은 이쯤에서 이야기를 마무리해보려 합니다.

현재까지 `kongnamul`의 방향성은 아래와 같이 정리되어 왔습니다.

```
웹 어플리케이션에서 상태와 UI 사이의 관계를 일관되게 유지하기 위해 존재합니다.
                        ↓
웹 어플리케이션에서 상태와 UI 사이의 관계를 일관되게 유지하기 위한 라이브러리입니다.
                        ↓
웹 어플리케이션의 UI를 선언적으로 관리하는 라이브러리입니다.
```

비록 오늘은 코드를 단 한 줄도 작성하지 못했지만 꽤나 큰 결정들을 많이 내렸습니다.  
아쉬울 수 있지만 시작이 반입니다.

결과적으로는 익숙하고 당연하게 느껴질지 모르는 내용이지만,  
React가 사라진 세상에 남긴 첫 걸음이라 생각하면 의미있는 발자취라 생각합니다.

내일부터는 본격적으로 오늘 내린 결정들을 실제로 구현하기 시작할 예정입니다.  
**상태 변화와 DOM 업데이트를 동기화하는 방법**과 사용자가 **선언적으로 사용하기 위한 추상화 여정**이 시작되지 않을까 싶습니다.

오늘도 무사히 살아남아서 다행입니다.  

감사합니다.

---

### [Appendix]

혹시나 본문을 읽으면서 저와 같은 의문이 생기신 분들을 위해 부록을 작성해두었습니다.

- [[1]](./day-1a.md/#1-react는-정말-라이브러리인가요) - React는 프레임워크가 아닌 순수한 라이브러리라 말할 수 있을까요?
- [[2]](./day-1a.md/#2-dom은-왜-트리-구조를-좋아할까요) - DOM은 트리 구조가 아닌 다른 구조가 될 수는 없을까요?
